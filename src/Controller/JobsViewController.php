<?php
namespace App\Controller;
use Cake\I18n\Time;
use App\Model\Entity\Job;
use App\Model\Table\JobsTable;
use Cake\Datasource\Exception\RecordNotFoundException;
use Cake\Datasource\ResultSetInterface;
use Cake\Http\Response;
ob_start();

/**
 * Jobs Controller
 *
 * @property JobsTable $Jobs
 *
 * @method Job[]|ResultSetInterface paginate($object = null, array $settings = [])
 */
class JobsViewController extends AppController
{
    /**
     * Index method
     *
     * @return Response|void
     */

    public function initialize()
    {
        parent::initialize(); // TODO: Change the autogenerated stub
        $this->loadModel('Jobs');
        $this->loadModel('Employers');
        $this->loadComponent('Paginator');
        $this->Auth->allow(['index','view','search']);
        $this->paginate = [
            'limit'=>'6'
        ];
    }

    public function isAuthorized($user = null) {
        if( $this->Auth->user('type')=='Candidate'){
            if (in_array($this->request->action, ['applyform', 'confirm'])) {

                return true;
            }
        }
        else{
            return false;
        }



        return parent::isAuthorized($user);
    }

    public function index()
    {
        $this->loadComponent('Paginator');
        $this->loadModel('Jobs');
        $jobs = $this->Jobs->find()->where(['published' => 1, 'archived' => 0]);
        $this->set(compact('jobs'));
        $this->paginate = [
            'limit'=>'6'
        ];
        $job = $this->Paginator->paginate($this->Jobs->find()->where(['published' => 1, 'archived' => 0]));
        $this->set('jobs',$job);
        $queryTermsString = $this->getRequest()->getQuery('query');
        //$selectedTagId = (int)$this->getRequest()->getQuery('tag');

        // Split the query string based on one or more whitespace characters (\s+).
        $queryTermsArray = preg_split('/\s+/', $queryTermsString);

        // We want to search for each term independently. If the user provided multiple terms, such as "job interview", then
        // we should find all articles where:
        //  (The title includes "job" OR the body includes "job")
        //   AND
        //  (The title includes "interview" OR the body includes "interview")
        // We also need to search for articles that haven't been archived
        // Notice how for each term, we need to build a condition such as "title LIKE ... OR body LIKE ...".
        // This is what happens in the loop below, we build a collection of these "OR" statements.
        $queryTermConditions = [];
        foreach ($queryTermsArray as $term) {
            $queryTermConditions[] = [
                'AND' => [
                    'Jobs.archived' => false,
                    'Jobs.published' => true,
                    'OR' => [
                        'Jobs.name LIKE' => "%{$term}%",
                        'Jobs.job_details LIKE' => "%{$term}%",
                        'Employers.company_name LIKE' => "%{$term}%",
                        'Employers.industry LIKE' => "%{$term}%",
                        'Employers.location LIKE' => "%{$term}%"
                    ]]];
        }

        // Once we have a collection of or (title LIKE ... OR body LIKE ...) statements, then we need to combine each
        // one using an AND (see comments above for example). By default, if we provide an array of conditions to
        // the where() method, then it will join them all together using AND, which is exactly what we want.
        $jobsQuery = $this->Jobs->find('all', array('contain' => array('Employers')))->where($queryTermConditions);

        // Filtering data by associations is documented here:
        // https://book.cakephp.org/3.0/en/orm/query-builder.html#filtering-by-associated-data
        // Indeed, the example at that piece of documentation is exactly what we are trying to do here - filter articles
        // by their tags.
//        if ($selectedTagId > 0) {
//            $articlesQuery->matching('Tags', function (Query $query) use ($selectedTagId) {
//                return $query->where(['Tags.id' => $selectedTagId]);
//            });
//        }

        $this->set('jobs', $this->paginate($jobsQuery));



        // Pass the query the user asked for to the view, so we can say something like "Results for 'Blah'..." to
        // confirm that we did indeed search what they asked us to. It also means that we can populate the search
        // text input with the string, so the user can perform the search again.
        $this->set('query', $queryTermsString);


    }

    /**
     * View method
     *
     * @param string|null $id Job id.
     * @return Response|void
     * @throws RecordNotFoundException When record not found.
     */
    public function view($id = null)
    {

        $job = $this->Jobs->get($id, [
            'contain' => ['Applications']
        ]);

        $this->set('job', $job);
    }

    public function applyform($id = null)
    {
        $job = $this->Jobs->get($id, [
            'contain' => ['Applications']
        ]);
        $this->set('job', $job);

        $this->loadModel('Candidates');
        $this->loadModel('Applications');
        $userID = $this->Auth->user('id');
        $candidates=$this->Candidates->find('all',['conditions'=>['user_id'=>$userID]])
            ->contain(['Skills', 'Qualifications','JobHistories'])->toList()[0];
        $candidateID=$candidates->id;
        $candidate = $this->Candidates->get($candidateID, [
            'contain' => ['Skills', 'Qualifications','JobHistories']
        ]);

        if ($this->request->is(['patch', 'post', 'put'])) {
            $application = $this->Applications->newEntity();
            $application->date = Time::now();
            $application->candidate_id = $candidateID;
            $application->job_id = $id;
            $application->first_name = $this->request->getData()['first_name'];
            $application->last_name = $this->request->getData()['last_name'];
            $application->email = $this->request->getData()['email'];
            $application->phone_no = $this->request->getData()['phone_no'];
            $application->country = $this->request->getData()['country'];
            $application->created=Time::now();
            $application ->state=$this->request->getData()['state'];
            if ($this->request->getData()['resumeSelect'] == 'uploadResume'&&$this->request->getData()['file']['size'] > 0) {
                //var_dump( $this->request->getData());
                $myname = $this->request->getData()['file']['name'];
                $mytmp = $this->request->getData()['file']['tmp_name'];
//            $myext = substr(strrchr(($myname), "."), 1);
//            $mypath = "upload/".$myname.".".$myext;
                $mypath = "/upload/" . $myname;
                $application->postname = $myname;
                $application->postpath = $mypath;

                move_uploaded_file($mytmp, WWW_ROOT . $mypath);
            }
            elseif ($this->request->getData()['resumeSelect'] =='selectResume'){
                $application->postname = $candidate->postname;
                $application->postpath = $candidate->postpath;

            }
            if($this->Applications->save($application)) {
                $this->Flash->success(__('Your application has been submitted'));
                return $this->redirect(['action' => 'view', $id]);
            }

        }
        $this->set(compact('candidate'));
    }


    public function confirm(){
        $this->viewBuilder()->setLayout('default');
    }


    public function search()
    {
        $queryTermsString = $this->getRequest()->getQuery('query');
        //$selectedTagId = (int)$this->getRequest()->getQuery('tag');

        // Split the query string based on one or more whitespace characters (\s+).
        $queryTermsArray = preg_split('/\s+/', $queryTermsString);

        // We want to search for each term independently. If the user provided multiple terms, such as "job interview", then
        // we should find all articles where:
        //  (The title includes "job" OR the body includes "job")
        //   AND
        //  (The title includes "interview" OR the body includes "interview")
        // We also need to search for articles that haven't been archived
        // Notice how for each term, we need to build a condition such as "title LIKE ... OR body LIKE ...".
        // This is what happens in the loop below, we build a collection of these "OR" statements.
        $queryTermConditions = [];
        foreach ($queryTermsArray as $term) {
            $queryTermConditions[] = [
                'AND' => [
                    'Jobs.archived' => false,
                    'OR' => [
                        'Jobs.name LIKE' => "%{$term}%",
                        'Jobs.job_details LIKE' => "%{$term}%",
                        'Employers.company_name LIKE' => "%{$term}%",
                        'Employers.industry LIKE' => "%{$term}%",
                        'Employers.location LIKE' => "%{$term}%"
                    ]]];
        }

        // Once we have a collection of or (title LIKE ... OR body LIKE ...) statements, then we need to combine each
        // one using an AND (see comments above for example). By default, if we provide an array of conditions to
        // the where() method, then it will join them all together using AND, which is exactly what we want.
        $jobsQuery = $this->Jobs->find('all', array('contain' => array('Employers')))->where($queryTermConditions);

        // Filtering data by associations is documented here:
        // https://book.cakephp.org/3.0/en/orm/query-builder.html#filtering-by-associated-data
        // Indeed, the example at that piece of documentation is exactly what we are trying to do here - filter articles
        // by their tags.
//        if ($selectedTagId > 0) {
//            $articlesQuery->matching('Tags', function (Query $query) use ($selectedTagId) {
//                return $query->where(['Tags.id' => $selectedTagId]);
//            });
//        }

        $this->set('jobs', $this->paginate($jobsQuery));


        // Pass the query the user asked for to the view, so we can say something like "Results for 'Blah'..." to
        // confirm that we did indeed search what they asked us to. It also means that we can populate the search
        // text input with the string, so the user can perform the search again.
        $this->set('query', $queryTermsString);

        $this->viewBuilder()->setLayout('default');
    }
}

