<?php
namespace App\Controller;
use App\Model\Entity\ArticleView;
use Cake\I18n\Time;
use App\Model\Entity\Article;
use App\Model\Table\ArticlesTable;
use Cake\Datasource\Exception\RecordNotFoundException;
use Cake\Datasource\ResultSetInterface;
use Cake\Http\Response;
ob_start();

/**
 * articles Controller
 *
 * @property ArticlesTable $Articles
 *
 * @method Job[]|ResultSetInterface paginate($object = null, array $settings = [])
 */
class ArticlesViewController extends AppController
{

    /**
     * Index method
     *
     * @return Response|void
     */

    public function initialize()
    {
        parent::initialize(); // TODO: Change the autogenerated stub
        $this->loadModel('Articles');
        $this->loadComponent('Paginator');
        $this->Auth->allow(['index','view','search']);
        $this->paginate = [
            'limit'=>'10'
        ];
    }

    public function isAuthorized($user = null) {
        if( $this->Auth->user('type')=='Candidate'){
            if (in_array($this->request->action, ['applyform', 'confirm'])) {

                return true;
            }
        }
        else{
            return false;
        }



        return parent::isAuthorized($user);
    }

    public function index()
    {
        $this->loadComponent('Paginator');
        $this->loadModel('Articles');
        $articles = $this->Articles->find()->where(['published' => 1, 'archived' => 0]);
        $this->set(compact('articles'));
        $this->paginate = [
            'limit'=>'6'
        ];
        $articles = $this->Paginator->paginate($this->Articles->find()->where(['published' => 1]));
        $this->set('articles',$articles);
        $queryTermsString = $this->getRequest()->getQuery('query');
        //$selectedTagId = (int)$this->getRequest()->getQuery('tag');

        // Split the query string based on one or more whitespace characters (\s+).
        $queryTermsArray = preg_split('/\s+/', $queryTermsString);

        // We want to search for each term independently. If the user provided multiple terms, such as "job interview", then
        // we should find all articles where:
        //  (The title includes "job" OR the body includes "job")
        //   AND
        //  (The title includes "interview" OR the body includes "interview")
        // We also need to search for articles that haven't been archived
        // Notice how for each term, we need to build a condition such as "title LIKE ... OR body LIKE ...".
        // This is what happens in the loop below, we build a collection of these "OR" statements.
        $queryTermConditions = [];
        foreach ($queryTermsArray as $term) {
            $queryTermConditions[] = [
                'AND' => [
                    'Articles.archived' => false,
                    'Articles.published' => true,
                    'OR' => [
                        'Articles.title LIKE' => "%{$term}%",
                        'Articles.body LIKE' => "%{$term}%",
                    ]]];
        }

        // Once we have a collection of or (title LIKE ... OR body LIKE ...) statements, then we need to combine each
        // one using an AND (see comments above for example). By default, if we provide an array of conditions to
        // the where() method, then it will join them all together using AND, which is exactly what we want.
        $articlesQuery = $this->Articles->find()->where($queryTermConditions);

        // Filtering data by associations is documented here:
        // https://book.cakephp.org/3.0/en/orm/query-builder.html#filtering-by-associated-data
        // Indeed, the example at that piece of documentation is exactly what we are trying to do here - filter articles
        // by their tags.
//        if ($selectedTagId > 0) {
//            $articlesQuery->matching('Tags', function (Query $query) use ($selectedTagId) {
//                return $query->where(['Tags.id' => $selectedTagId]);
//            });
//        }

        $this->set('articles', $this->paginate($articlesQuery));



        // Pass the query the user asked for to the view, so we can say something like "Results for 'Blah'..." to
        // confirm that we did indeed search what they asked us to. It also means that we can populate the search
        // text input with the string, so the user can perform the search again.
        $this->set('query', $queryTermsString);


    }




    /**
     * View method
     *
     * @param string|null $id Article id.
     * @return Response|void
     * @throws RecordNotFoundException When record not found.
     */
    public function view($slug = null)
    {
        $article = $this->Articles->findBySlug($slug)->contain(['Tags'])
            ->firstOrFail();
        $this->set(compact('article'));

        if (true){
            $view = new ArticleView([
                'article_id' => $article->id,
            ]);
            $this->viewBuilder()->setLayout('default');
            $this->set(compact('article', $article));
        } else {
            throw new \Cake\Http\Exception\NotFoundException("Article not found");
        }

        $this->paginate=[
            'limit'=>'1'
        ];
    }


    public function search()
    {
        $queryTermsString = $this->getRequest()->getQuery('query');
        //$selectedTagId = (int)$this->getRequest()->getQuery('tag');

        // Split the query string based on one or more whitespace characters (\s+).
        $queryTermsArray = preg_split('/\s+/', $queryTermsString);

        // We want to search for each term independently. If the user provided multiple terms, such as "article interview", then
        // we should find all articles where:
        //  (The title includes "article" OR the body includes "article")
        //   AND
        //  (The title includes "interview" OR the body includes "interview")
        // We also need to search for articles that haven't been archived
        // Notice how for each term, we need to build a condition such as "title LIKE ... OR body LIKE ...".
        // This is what happens in the loop below, we build a collection of these "OR" statements.
        $queryTermConditions = [];
        foreach ($queryTermsArray as $term) {
            $queryTermConditions[] = [
                'AND' => [
                    'Articles.archived' => false,
                    'OR' => [
                        'Articles.name LIKE' => "%{$term}%",
                        'Articles.body LIKE' => "%{$term}%",
                    ]]];
        }

        // Once we have a collection of or (title LIKE ... OR body LIKE ...) statements, then we need to combine each
        // one using an AND (see comments above for example). By default, if we provide an array of conditions to
        // the where() method, then it will join them all together using AND, which is exactly what we want.
//        $articlesQuery = $this->Articles->find('all', array('contain' => array('Employers')))->where($queryTermConditions);

        // Filtering data by associations is documented here:
        // https://book.cakephp.org/3.0/en/orm/query-builder.html#filtering-by-associated-data
        // Indeed, the example at that piece of documentation is exactly what we are trying to do here - filter articles
        // by their tags.
//        if ($selectedTagId > 0) {
//            $articlesQuery->matching('Tags', function (Query $query) use ($selectedTagId) {
//                return $query->where(['Tags.id' => $selectedTagId]);
//            });
//        }

        $this->set('articles', $this->paginate($articlesQuery));


        // Pass the query the user asked for to the view, so we can say something like "Results for 'Blah'..." to
        // confirm that we did indeed search what they asked us to. It also means that we can populate the search
        // text input with the string, so the user can perform the search again.
        $this->set('query', $queryTermsString);

        $this->viewBuilder()->setLayout('default');
    }
}

